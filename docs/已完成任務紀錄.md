# 系統名稱查找問題修復任務 - 已完成紀錄

## ✅ 任務1: 產品BOM系統重構 (已完成)

### 📋 **任務目標**
調整資料結構使用代號而非名稱，解決因名稱重複導致的 BOM 計算錯誤。

### 🔧 **修改內容**

#### 1. **產品詳情頁面** (`src/app/dashboard/products/[id]/page.tsx`)
- 新增 `specificMaterialCodes` 和 `commonMaterialCodes` 欄位到介面定義
- 修改載入邏輯，同時獲取材料的代號和名稱
- 更新 productData 物件包含代號欄位

```typescript
// 修改前
specificMaterialNames: string[]
commonMaterialNames: string[]

// 修改後
specificMaterialNames: string[]
specificMaterialCodes: string[]  // 新增
commonMaterialNames: string[]
commonMaterialCodes: string[]    // 新增
```

#### 2. **工單建立頁面** (`src/app/dashboard/work-orders/create/page.tsx`)
- 新增材料代號欄位到產品介面
- 修改載入邏輯獲取代號
- 重構 BOM 計算邏輯，優先使用代號匹配，備用名稱匹配

```typescript
// 優先使用代號匹配
const material = materials.find(m => {
  if (selectedProduct.specificMaterialCodes && selectedProduct.specificMaterialCodes.length > 0) {
    return m.code === materialIdentifier
  }
  return m.name === materialIdentifier || m.code === materialIdentifier
})
```

#### 3. **產能對話框** (`src/app/dashboard/inventory/components/ProductionCapacityDialog.tsx`)
- 同步更新介面和載入邏輯
- 修改材料需求計算，優先使用代號

### 🔍 **測試驗證**
- ✅ 產品詳情頁面正常載入並顯示材料
- ✅ 工單建立 BOM 計算使用代號匹配
- ✅ 產能評估材料需求計算正確
- ✅ 向後相容，舊資料仍可使用名稱匹配

### 💡 **技術要點**
1. **向後相容設計**：保留名稱匹配作為備用方案
2. **優先順序**：代號 > 名稱 > ID
3. **UI 不變**：用戶介面顯示仍使用名稱
4. **資料完整性**：同時儲存代號和名稱

---

## ✅ 任務2: 採購收貨系統修復 (已完成)

### 📋 **任務目標**
強制使用 itemRef 路徑，避免名稱依賴導致的收貨錯誤。

### 🔧 **已修改內容**

#### 1. **後端 API** (`functions/src/api/purchaseOrders.ts`)
- 強制要求有效的 `itemRefPath`
- 優先使用路徑中的 ID 進行物品查找
- 保留代號查找作為備用方案
- 改進錯誤提示和日誌

#### 2. **前端收貨對話框**
- `NewReceiveDialog.tsx` 和 `ReceiveDialog.tsx`
- 改進 itemRef 提取邏輯
- 修復 itemRef.id 物件轉字串問題
- 增加類型檢查和安全轉換

### ✅ **問題已解決**
通過 Firebase Functions 日誌分析，發現前端傳送的 `itemRefPath` 是完整的 Firestore 路徑格式：
```
projects/deer-lab/databases/(default)/documents/materials/ylOWa2xsPFnqjbiiAjKJ
```
但 `db.doc()` 需要相對路徑格式：
```
materials/ylOWa2xsPFnqjbiiAjKJ
```

### 🔧 **最終修復**
修改前端代碼，正確提取 Firestore DocumentReference 的相對路徑：

#### 在 `NewReceiveDialog.tsx` 和 `ReceiveDialog.tsx` 中：
```typescript
// 查找 "documents/" 之後的部分
const documentsIndex = segments.indexOf('documents');
if (documentsIndex !== -1 && documentsIndex + 2 < segments.length) {
  const collection = segments[documentsIndex + 1];
  const documentId = segments[documentsIndex + 2];
  itemRefPath = `${collection}/${documentId}`;
}
```

### 🔍 **錯誤根因分析**
1. **前端**：Firebase DocumentReference 物件包含完整路徑
2. **後端**：`db.doc()` 只接受相對路徑
3. **解決方案**：路徑轉換邏輯，提取 `documents/` 之後的 `collection/documentId`

---

## 📝 **開發規範要點**

1. **統一ID系統**：employeeId = Firebase Auth UID = Firestore 文檔ID
2. **API調用**：使用 `useApiClient` Hook，禁止直接使用 `httpsCallable`
3. **資料查找優先順序**：ID/代號 > 名稱（僅作為備用或顯示）
4. **部署流程**：`npm run build` → `cp .next functions/` → `rm cache` → `firebase deploy`

## 🚀 **後續任務**
- 任務3: 工單系統修復 - 香精使用ID而非名稱
- 任務4: 權限系統修復 - 移除硬編碼名稱判斷
- 任務5: 篩選功能修復 - 供應商篩選使用ID
- 任務6: API層修復 - 使用ID查找和驗證
- 任務7: 類型定義更新 - 清理和標記廢棄欄位
- 任務8: 搜尋功能優化保留 - 確保用戶體驗不變