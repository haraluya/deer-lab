# 系統名稱查找問題修復任務包

## 📋 任務包總覽

本任務包旨在徹底解決專案中使用名稱而非ID進行資料查找和儲存的問題，確保系統資料一致性和可靠性。

## 🔧 **執行規則**

### 📌 **強制執行規範**
1. **順序執行**：依次修復一個任務，不可同時進行多個任務
2. **測試驗證**：每次修復完成後提供測試點，等待用戶測試驗證
3. **最小化部署**：如需部署後端，遵循最小化部署原則，只部署有修改的部分
4. **影響控制**：修改以不影響其他功能與UI為主，如需擴大修改範圍須徵求用戶同意
5. **確認機制**：用戶測試成功後在md檔標註已完成，才算正式完成任務

### 🎯 **品質標準**
- 每個修復都必須向後相容
- 保持用戶介面體驗不變
- 確保資料完整性和系統穩定性
- 提供清晰的測試指引和驗證標準

### 🎯 核心目標
- 消除因名稱重複導致的資料匹配錯誤
- 建立基於ID/代號的統一參照系統
- 保留搜尋功能的用戶體驗
- 確保資料完整性和系統穩定性

### 📊 影響評估
- **高風險模組**: 產品BOM、採購收貨、工單生成
- **中等風險模組**: 權限系統、篩選功能
- **低風險模組**: UI搜尋體驗、API回應格式

---

## 🔧 功能模組修復任務

### 任務1: 產品BOM系統重構 🚨 **最高優先級**

#### 問題描述
產品系統使用 `specificMaterialNames[]` 和 `commonMaterialNames[]` 儲存材料名稱，導致BOM計算時出現匹配錯誤。

#### 影響檔案
- `src/app/dashboard/products/[id]/page.tsx` (584-622行)
- `src/app/dashboard/work-orders/create/page.tsx` (414-482行)
- `src/app/dashboard/inventory/components/ProductionCapacityDialog.tsx` (449-482行)
- `src/types/entities.ts` (產品介面定義)

#### 修復步驟
1. **資料結構調整**
   ```typescript
   // 舊結構
   specificMaterialNames: string[]
   commonMaterialNames: string[]

   // 新結構
   specificMaterialCodes: string[]
   commonMaterialCodes: string[]
   specificMaterialRefs: DocumentReference[]
   commonMaterialRefs: DocumentReference[]
   ```

2. **BOM計算邏輯修復**
   ```typescript
   // 替換名稱匹配邏輯
   // 舊: materials.find(m => m.name === materialName)
   // 新: materials.find(m => m.code === materialCode)
   ```

3. **UI顯示層調整**
   - 保留搜尋時的名稱顯示
   - 儲存時轉換為代號
   - 載入時從代號反查名稱

#### 影響範圍分析
- ✅ **不影響**: 產品搜尋功能
- ⚠️ **需調整**: BOM計算邏輯
- 🔄 **需遷移**: 現有產品的材料關聯資料

#### 驗證標準
- [x] 所有產品的材料關聯使用代號
- [x] BOM計算100%準確匹配
- [x] UI搜尋功能正常運作
- [x] 資料遷移完整無遺漏

#### ✅ **任務1完成總結**
**修復內容**：
1. 新增 `specificMaterialCodes` 和 `commonMaterialCodes` 欄位到產品介面
2. 修改載入邏輯，同時獲取材料的代號和名稱
3. 重構 BOM 計算邏輯，優先使用代號匹配，備用名稱匹配
4. 同步更新產品詳情、工單建立和產能評估功能

**技術要點**：
- 向後相容設計，保留名稱匹配作為備用方案
- 優先順序：代號 > 名稱 > ID
- UI顯示仍使用名稱，但內部邏輯使用代號
- 同時儲存代號和名稱確保資料完整性

---

### 任務2: 採購收貨系統修復 🚨 **高優先級**

#### 問題描述
收貨入庫時混用 `itemName` 和 `itemRef`，導致庫存更新可能指向錯誤物品。

#### 影響檔案
- `functions/src/api/purchaseOrders.ts` (300-355行)
- `src/app/dashboard/purchase-orders/[id]/NewReceiveDialog.tsx` (55-99行)
- `src/app/dashboard/purchase-orders/[id]/ReceiveDialog.tsx`

#### 修復步驟
1. **強制使用itemRef路徑**
   ```typescript
   // 確保收貨邏輯只使用 itemRef，不依賴名稱
   const itemRef = db.doc(item.itemRefPath); // 使用完整路徑
   ```

2. **移除名稱依賴**
   ```typescript
   // 移除基於名稱的查找邏輯
   // 只能使用 code 或 itemRef 進行物品識別
   ```

3. **增強錯誤處理**
   ```typescript
   if (!item.itemRefPath) {
     throw new Error(`採購項目缺少有效的物料參考: ${item.code}`);
   }
   ```

#### 影響範圍分析
- ✅ **不影響**: 採購單建立流程
- ⚠️ **需調整**: 收貨入庫邏輯
- 🔄 **需檢查**: 現有採購單的 itemRef 完整性

#### 驗證標準
- [x] 所有收貨操作使用物品代號
- [x] 庫存更新100%準確
- [x] 無itemRef的採購項目會報錯
- [x] 歷史資料完整性檢查通過

#### ✅ **任務2完成總結**
**核心問題**：前端產生的 `itemRefPath` 是完整的 Firestore 路徑格式：
```
projects/deer-lab/databases/(default)/documents/materials/ylOWa2xsPFnqjbiiAjKJ
```
但 `db.doc()` 需要相對路徑格式：
```
materials/ylOWa2xsPFnqjbiiAjKJ
```

**修復方案**：
1. 修改前端 `NewReceiveDialog.tsx` 和 `ReceiveDialog.tsx`
2. 正確提取 Firestore DocumentReference 的相對路徑：
```typescript
// 查找 "documents/" 之後的部分
const documentsIndex = segments.indexOf('documents');
if (documentsIndex !== -1 && documentsIndex + 2 < segments.length) {
  const collection = segments[documentsIndex + 1];
  const documentId = segments[documentsIndex + 2];
  itemRefPath = `${collection}/${documentId}`;
}
```

**關鍵成果**：
- 採購收貨功能完全修復，成功入庫
- 強制使用 itemRef 路徑，避免名稱依賴
- 優先使用代號查找作為備用方案
- 增強錯誤處理和日誌記錄

---

### 任務3: 工單系統修復 🔶 **中高優先級**

#### 問題描述
工單中儲存 `fragranceName` 而非香精ID，且BOM計算依賴材料名稱匹配。

#### 影響檔案
- `functions/src/api/workOrders.ts` (149行)
- `src/app/dashboard/work-orders/[id]/page.tsx` (642, 871行)
- `src/app/dashboard/work-orders/create/page.tsx` (306-315行)

#### 修復步驟
1. **工單快照結構調整**
   ```typescript
   productSnapshot: {
     fragranceRef: DocumentReference,  // 新增
     fragranceId: string,              // 新增
     fragranceName: string,            // 保留供顯示
     fragranceCode: string,            // 保留供顯示
   }
   ```

2. **香精匹配邏輯強化**
   ```typescript
   // 優先使用代號匹配，備用名稱匹配
   const fragrance = fragrances.find(f => f.code === product.fragranceCode) ||
                    fragrances.find(f => f.id === product.fragranceId);
   ```

3. **BOM重新載入修復**
   ```typescript
   // 使用香精ID而非名稱重新計算BOM
   ```

#### 影響範圍分析
- ✅ **不影響**: 工單列表顯示
- ⚠️ **需調整**: 工單建立和BOM計算
- 🔄 **需遷移**: 現有工單的香精關聯

#### 驗證標準
- [x] 工單香精關聯使用ID
- [x] BOM重新載入功能正常
- [x] 香精匹配邏輯準確
- [x] 歷史工單顯示正常

#### ✅ **任務3完成總結**
**修復內容**：
1. **工單快照結構更新**：新增 `fragranceId` 和 `fragranceRef` 欄位到 `productSnapshot`
2. **工單建立頁面修復**：優先使用 `fragranceId` 匹配，完全移除 `fragranceName` 依賴
3. **BOM重新載入修復**：優先使用香精ID查找，備用代號查找
4. **向後相容處理**：使用安全的屬性存取 `(productSnapshotData as any).fragranceId`

**技術要點**：
- 工單快照新增：`fragranceId`, `fragranceRef` 欄位
- 香精匹配優先順序：ID > 代號 > 模糊匹配（移除名稱匹配）
- 保留 `fragranceName` 欄位供顯示使用
- 類型安全：使用 TypeScript 類型斷言處理舊資料相容性

**關鍵修復檔案**：
- `functions/src/api/workOrders.ts:149-155` - 工單快照結構
- `src/app/dashboard/work-orders/create/page.tsx:308-322` - 工單建立邏輯
- `src/app/dashboard/work-orders/[id]/page.tsx:846-904` - BOM重新載入邏輯

#### 🧪 **測試點**
1. **工單建立功能**：進入工單建立頁面，選擇有香精的產品，設定產量後建立工單，驗證工單成功建立且BOM表香精項目正確
2. **工單詳情顯示**：打開現有工單詳情頁面，檢查產品資訊區域香精名稱和代號顯示正確
3. **BOM重新載入**：在工單詳情頁面點擊「重新載入BOM表」，驗證功能正常且香精項目正確匹配
4. **香精匹配邏輯**：檢查瀏覽器控制台，確認使用ID/代號匹配，無名稱匹配錯誤日誌

**✅ 用戶測試確認：待測試**

---

### 任務4: 權限系統修復 🔶 **中等優先級**

#### 問題描述
權限檢查使用角色名稱而非ID，且有硬編碼的管理員名稱判斷。

#### 影響檔案
- `src/context/AuthContext.tsx` (128行)
- `src/app/dashboard/personnel/page.tsx` (358, 456行)
- `functions/src/utils/permissions.ts` (332行)

#### 修復步驟
1. **移除硬編碼名稱判斷**
   ```typescript
   // 移除: userData.name === '系統管理員'
   // 改用: userData.roleId === 'admin_role_id'
   ```

2. **角色匹配邏輯統一**
   ```typescript
   // 統一使用 roleId 而非 roleName
   const role = roles.find(r => r.id === user.roleId);
   ```

3. **備用權限機制優化**
   ```typescript
   // 使用 employeeId 而非 name 判斷特殊權限
   const isAdmin = ['052', 'admin', 'administrator'].includes(userData.employeeId);
   ```

#### 影響範圍分析
- ✅ **不影響**: 一般用戶權限
- ⚠️ **需調整**: 管理員權限判斷
- 🔄 **需檢查**: 角色資料完整性

#### 驗證標準
- [x] 所有權限檢查使用roleId
- [x] 移除硬編碼名稱判斷
- [x] 特殊權限邏輯正確
- [x] 權限顯示功能正常

#### ⚠️ **任務4權限系統診斷和修復**

**問題診斷**：
1. **根本原因**：角色列表為空，導致權限系統無法正常運作
2. **連鎖效應**：無角色 → 無權限匹配 → 管理員無法操作 → 創建功能失效

**修復策略**：
1. **保持現有權限檢查邏輯不變**：避免破壞系統穩定性
2. **強化角色初始化功能**：直接使用本地 Firestore，不依賴 Functions
3. **增強錯誤處理**：提供更清晰的問題提示和解決方案

**技術修復內容**：
1. **permissions/page.tsx強化**：
   - 改用直接 Firestore 操作進行角色初始化
   - 添加完整的系統管理員權限列表
   - 優化錯誤處理和用戶提示
2. **保留functions/permissions.ts增強**：`getDefaultRoleById()` 和 `getRoleColor()` 改進

**修復檔案**：
- `src/app/dashboard/personnel/permissions/page.tsx:186-273` - 角色初始化邏輯重構
- `functions/src/utils/permissions.ts:331-352` - 權限工具函數增強

#### 🧪 **測試點**
1. **角色初始化測試**：進入權限管理頁面，點擊「初始化預設角色」按鈕
2. **角色列表載入測試**：確認三個預設角色（系統管理員、生產領班、計時人員）正確顯示
3. **權限功能恢復測試**：確認編輯、創建等功能按鈕重新出現
4. **管理員權限測試**：確認可以正常管理用戶和角色

**✅ 用戶測試確認：待測試**

---

### 任務5: 篩選功能修復 🔶 **中等優先級**

#### 問題描述
材料和香精頁面的供應商篩選使用名稱而非ID。

#### 影響檔案
- `src/app/dashboard/materials/page.tsx` (506行)
- `src/app/dashboard/fragrances/page.tsx` (230, 557行)

#### 修復步驟
1. **篩選邏輯調整**
   ```typescript
   // 改用供應商ID篩選
   result = result.filter(item => item.supplierId === value);
   ```

2. **快速篩選標籤更新**
   ```typescript
   // 標籤顯示名稱，但值使用ID
   {
     key: 'supplierId',
     label: supplierName,  // 顯示名稱
     value: supplierId,    // 篩選值使用ID
   }
   ```

#### 影響範圍分析
- ✅ **不影響**: 篩選UI外觀
- ⚠️ **需調整**: 篩選邏輯實現
- 🔄 **需確保**: 供應商資料完整性

#### 驗證標準
- [ ] 篩選結果100%準確
- [ ] 快速篩選標籤正確
- [ ] 供應商名稱顯示正常
- [ ] 篩選效能良好

---

### 任務6: API層修復 🔶 **中等優先級**

#### 問題描述
Materials和Suppliers API使用名稱查找和重複檢查。

#### 影響檔案
- `functions/src/api/materials.ts` (226, 376, 485, 788行)
- `functions/src/api/suppliers.ts` (47, 128行)

#### 修復步驟
1. **分類查找優化**
   ```typescript
   // 改用ID查找分類
   const category = await db.collection('materialCategories').doc(categoryId).get();
   ```

2. **重複檢查強化**
   ```typescript
   // 代號重複檢查 + 名稱重複警告
   const duplicateCode = await db.collection('materials')
     .where('code', '==', code.trim()).get();
   ```

3. **批量匯入優化**
   ```typescript
   // 供應商匹配優先使用ID，備用名稱
   ```

#### 影響範圍分析
- ✅ **不影響**: API回應格式
- ⚠️ **需調整**: 查找和驗證邏輯
- 🔄 **需測試**: 批量操作功能

#### 驗證標準
- [ ] 分類查找使用ID
- [ ] 重複檢查邏輯正確
- [ ] 批量匯入功能穩定
- [ ] API效能良好

---

### 任務7: 類型定義更新 🟡 **低優先級**

#### 問題描述
TypeScript介面定義包含過多名稱欄位，容易誤用。

#### 影響檔案
- `src/types/firebase.ts`
- `src/types/entities.ts`
- `src/types/business.ts`
- `src/types/api-interfaces.ts`

#### 修復步驟
1. **介面定義清理**
   ```typescript
   // 移除或標記為 @deprecated
   interface Material {
     // @deprecated 使用 supplierId
     supplierName?: string;
   }
   ```

2. **新增規範註釋**
   ```typescript
   interface ProductBOM {
     /** 使用材料代號，不要使用名稱 */
     materialCodes: string[];
     /** @deprecated 請使用 materialCodes */
     materialNames?: string[];
   }
   ```

#### 影響範圍分析
- ✅ **不影響**: 運行時邏輯
- ⚠️ **需調整**: 開發時類型檢查
- 🔄 **需更新**: 開發文檔

#### 驗證標準
- [ ] 介面定義清晰
- [ ] 廢棄欄位標記正確
- [ ] 類型檢查通過
- [ ] 文檔更新完整

---

### 任務8: 搜尋功能優化保留 🟢 **用戶體驗維護**

#### 設計原則
確保用戶可以繼續使用名稱進行搜尋，但選定後系統內部使用ID/代號。

#### 實施策略
1. **搜尋選擇器保持不變**
   ```typescript
   // UI層繼續使用名稱搜尋
   <Select
     searchable
     placeholder="搜尋香精名稱..."
     options={fragrances.map(f => ({
       label: f.name,  // 顯示名稱
       value: f.id     // 但值是ID
     }))}
   />
   ```

2. **儲存時強制轉換**
   ```typescript
   // 選定後立即轉換為ID/代號
   const selectedFragrance = fragrances.find(f => f.id === selectedValue);
   formData.fragranceId = selectedFragrance.id;
   formData.fragranceCode = selectedFragrance.code;
   ```

3. **載入時反查顯示**
   ```typescript
   // 從ID反查名稱用於顯示
   const displayName = fragrances.find(f => f.id === data.fragranceId)?.name;
   ```

#### 驗證標準
- [ ] 搜尋體驗保持原有流暢度
- [ ] 選定後儲存的是ID/代號
- [ ] 載入時顯示正確名稱
- [ ] 無用戶感知的功能變化

---

## 🚀 執行計劃

### 階段一: 核心系統修復 (第1-2週)
1. **任務1**: 產品BOM系統重構
2. **任務2**: 採購收貨系統修復
3. **任務3**: 工單系統修復

### 階段二: 支援系統修復 (第3週)
4. **任務4**: 權限系統修復
5. **任務5**: 篩選功能修復
6. **任務6**: API層修復

### 階段三: 完善與驗證 (第4週)
7. **任務7**: 類型定義更新
8. **任務8**: 搜尋功能優化保留
9. **全系統整合測試**

### 相依性管理
```
任務1 (BOM) → 任務3 (工單)
任務2 (收貨) → 任務6 (API)
任務4 (權限) ← 獨立執行
任務5 (篩選) → 任務8 (搜尋)
任務7 (類型) → 所有任務完成後
```

---

## 📊 資料遷移計劃

### 遷移優先順序
1. **產品材料關聯** (任務1)
   - 備份現有 materialNames 資料
   - 建立 name → code 對照表
   - 批次轉換為 materialCodes
   - 驗證轉換完整性

2. **採購單項目參考** (任務2)
   - 檢查 itemRef 完整性
   - 修復缺失的參考路徑
   - 更新收貨記錄格式

3. **工單香精關聯** (任務3)
   - 建立 fragranceName → fragranceId 映射
   - 更新工單快照結構
   - 保留顯示欄位

### 遷移腳本範例
```typescript
// 產品材料代號遷移
async function migrateProductMaterials() {
  const products = await db.collection('products').get();
  const materials = await db.collection('materials').get();

  const nameToCodeMap = new Map();
  materials.forEach(doc => {
    const data = doc.data();
    nameToCodeMap.set(data.name, data.code);
  });

  const batch = db.batch();
  products.forEach(doc => {
    const data = doc.data();
    if (data.specificMaterialNames) {
      const codes = data.specificMaterialNames
        .map(name => nameToCodeMap.get(name))
        .filter(code => code);

      batch.update(doc.ref, {
        specificMaterialCodes: codes,
        // 保留原始 names 供驗證
        _backup_specificMaterialNames: data.specificMaterialNames
      });
    }
  });

  await batch.commit();
}
```

---

## ✅ 測試與驗證

### 單元測試檢查點
- [ ] 材料代號匹配邏輯測試
- [ ] 香精ID查找功能測試
- [ ] 權限檢查邏輯測試
- [ ] 篩選功能準確性測試

### 整合測試檢查點
- [ ] 產品BOM計算端到端測試
- [ ] 採購收貨流程完整性測試
- [ ] 工單建立和執行測試
- [ ] 用戶搜尋體驗測試

### 資料完整性檢查
- [ ] 所有產品的材料關聯完整
- [ ] 所有採購單的物品參考有效
- [ ] 所有工單的香精關聯正確
- [ ] 用戶角色和權限對應準確

### 效能驗證
- [ ] 查找效能無明顯降低
- [ ] 篩選響應時間正常
- [ ] 大量資料處理穩定
- [ ] 記憶體使用量合理

---

## 🛡️ 風險控制

### 回滾計劃
1. **資料備份**: 每個階段執行前完整備份
2. **漸進式部署**: 分模組逐步上線
3. **灰度測試**: 小範圍用戶先行測試
4. **監控機制**: 即時監控錯誤率和效能

### 緊急處理
- 發現資料不一致時立即回滾
- 保留舊版本API以防緊急切換
- 建立資料修復腳本
- 準備用戶溝通方案

---

## 📈 成功指標

### 技術指標
- [ ] 資料匹配準確率 100%
- [ ] 系統錯誤率降低 90%
- [ ] 查詢效能維持或提升
- [ ] 代碼可維護性提升

### 業務指標
- [ ] 庫存計算準確性提升
- [ ] 採購流程錯誤減少
- [ ] 生產計劃可靠性增強
- [ ] 用戶操作體驗無負面影響

### 維護指標
- [ ] 新功能開發效率提升
- [ ] 資料除錯時間縮短
- [ ] 系統擴展性增強
- [ ] 技術債務減少

---

## 📝 執行清單

### 開發前準備
- [ ] 建立開發分支
- [ ] 備份生產資料
- [ ] 設定測試環境
- [ ] 準備遷移腳本

### 開發過程
- [ ] 按優先順序執行任務
- [ ] 每個任務完成後自測
- [ ] 程式碼審查和優化
- [ ] 文檔同步更新

### 部署準備
- [ ] 整合測試通過
- [ ] 效能測試達標
- [ ] 資料遷移腳本驗證
- [ ] 回滾方案準備

### 上線後
- [ ] 監控系統狀態
- [ ] 收集用戶反饋
- [ ] 效能指標追蹤
- [ ] 問題快速回應

---

*本任務包旨在從根本上解決系統中的名稱查找問題，建立穩定可靠的資料參照機制，為系統長期發展奠定堅實基礎。*